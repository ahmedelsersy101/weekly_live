// ignore_for_file: unused_local_variable

import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:uuid/uuid.dart';
import 'package:flutter/material.dart';
import '../../data/models/task_model.dart';
import '../../data/models/weekly_state_model.dart';
import '../../data/models/recurrence_model.dart';
import '../../data/services/hive_service.dart';
import '../../../../core/models/settings_model.dart';
import '../../../../core/services/settings_service.dart';
import '../../../../core/services/notification_service.dart';
import '../../../../core/services/supabase_auth_service.dart';

part 'weekly_state.dart';

class WeeklyCubit extends Cubit<WeeklyState> {
  WeeklyCubit() : super(const WeeklyInitial()) {
    _initializeWithSampleData();
  }

  final _uuid = const Uuid();
  WeekStart _currentWeekStart = WeekStart.saturday; // Default week start

  void _initializeWithSampleData() async {
    List<TaskModel> tasks = HiveService.loadTasks();

    tasks = tasks.where((task) => !_isAutoGeneratedTask(task)).toList();

    if (tasks.isEmpty) {
      tasks = [];
    }

    try {
      final settings = await SettingsService.loadSettings();
      _currentWeekStart = settings.weekStart;
    } catch (e) {
      _currentWeekStart = WeekStart.saturday;
    }

    _updateState(tasks);
  }

  void updateWeekStart(WeekStart weekStart) {
    _currentWeekStart = weekStart;
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      _updateState(currentState.weeklyState.tasks);
    }
  }

  void addTask(
    String title,
    int dayOfWeek, {
    bool isImportant = false,
    TimeOfDay? reminderTime,
    TaskPriority priority = TaskPriority.medium,
    String categoryId = 'other',
    String? description,
    List<String> tags = const [],
    RecurrenceRule? recurrenceRule,
  }) async {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      // Get current user ID for the task
      final userId = await SupabaseAuthService.getUserId() ?? '';

      final newTask = TaskModel(
        id: _uuid.v4(),
        userId: userId,
        title: title,
        description: description,
        isCompleted: false,
        dayOfWeek: dayOfWeek,
        isImportant: isImportant,
        reminderTime: reminderTime,
        priority: priority,
        categoryId: categoryId,
        tags: tags,
        recurrenceRule: recurrenceRule,
      );

      final updatedTasks = List<TaskModel>.from(currentState.weeklyState.tasks)..add(newTask);

      // Schedule notification if reminder time is set
      if (reminderTime != null) {
        await _scheduleTaskNotification(newTask);
      }

      // If this is a recurring task, generate instances for the next few weeks
      if (recurrenceRule != null && recurrenceRule.isRecurring) {
        final recurringInstances = _generateRecurringInstances(newTask, recurrenceRule);
        updatedTasks.addAll(recurringInstances);

        // Schedule notifications for recurring instances
        for (final instance in recurringInstances) {
          if (instance.reminderTime != null) {
            await _scheduleTaskNotification(instance);
          }
        }
      }

      _updateState(updatedTasks);
    }
  }

  /// Atomically add the same task across multiple days in one state update
  Future<void> addTaskToDays(
    String title,
    Set<int> days, {
    bool isImportant = false,
    TimeOfDay? reminderTime,
    TaskPriority priority = TaskPriority.medium,
    String categoryId = 'other',
    String? description,
    List<String> tags = const [],
    RecurrenceRule? recurrenceRule,
  }) async {
    if (state is! WeeklySuccess) return;
    final currentState = state as WeeklySuccess;
    final userId = await SupabaseAuthService.getUserId() ?? '';

    // Ensure valid unique days (ignore invalid indices)
    final uniqueDays = days.where((d) => d >= 0 && d <= 6).toSet();
    if (uniqueDays.isEmpty) return;

    final List<TaskModel> newTasks = [];
    for (final day in uniqueDays) {
      final t = TaskModel(
        id: _uuid.v4(),
        userId: userId,
        title: title,
        description: description,
        isCompleted: false,
        dayOfWeek: day,
        isImportant: isImportant,
        reminderTime: reminderTime,
        priority: priority,
        categoryId: categoryId,
        tags: tags,
        recurrenceRule: recurrenceRule,
      );
      newTasks.add(t);
    }

    final updatedTasks = List<TaskModel>.from(currentState.weeklyState.tasks)..addAll(newTasks);

    // Schedule notifications after list prepared
    for (final task in newTasks) {
      if (task.reminderTime != null) {
        await _scheduleTaskNotification(task);
      }
    }

    _updateState(updatedTasks);
  }

  /// Update a task across selected days: add new days, remove deselected days, and update existing
  Future<void> updateTaskAcrossDays(
    String baseTaskId,
    Set<int> targetDays, {
    String? newTitle,
    bool? isImportant,
    TimeOfDay? reminderTime,
    String? categoryId,
    TaskPriority? priority,
  }) async {
    if (state is! WeeklySuccess) return;
    final currentState = state as WeeklySuccess;

    final baseTask = currentState.weeklyState.tasks.firstWhere((t) => t.id == baseTaskId);
    final String seriesKeyTitle = newTitle ?? baseTask.title;

    // Consider all tasks with the same title as belonging to the same logical series
    final List<TaskModel> series = currentState.weeklyState.tasks
        .where((t) => t.title == baseTask.title)
        .toList();

    final existingByDay = {for (final t in series) t.dayOfWeek: t};
    final normalizedTargetDays = targetDays.where((d) => d >= 0 && d <= 6).toSet();

    final List<TaskModel> tasksAfterRemoval = currentState.weeklyState.tasks.where((t) {
      // Remove series tasks that are not in target days or will be re-added/updated
      final isSameSeries = t.title == baseTask.title;
      if (!isSameSeries) return true;
      return normalizedTargetDays.contains(t.dayOfWeek);
    }).toList();

    // Update existing days and create missing ones
    final List<TaskModel> additionsOrUpdates = [];
    for (final d in normalizedTargetDays) {
      if (existingByDay.containsKey(d)) {
        final existing = existingByDay[d]!;
        final updated = existing.copyWith(
          title: seriesKeyTitle,
          isImportant: isImportant ?? existing.isImportant,
          reminderTime: reminderTime ?? existing.reminderTime,
          categoryId: categoryId ?? existing.categoryId,
          priority: priority ?? existing.priority,
        );
        additionsOrUpdates.add(updated);
      } else {
        // Create sibling instance for new day
        additionsOrUpdates.add(
          TaskModel(
            id: _uuid.v4(),
            userId: baseTask.userId,
            title: seriesKeyTitle,
            description: baseTask.description,
            isCompleted: false,
            dayOfWeek: d,
            isImportant: isImportant ?? baseTask.isImportant,
            reminderTime: reminderTime ?? baseTask.reminderTime,
            priority: priority ?? baseTask.priority,
            categoryId: categoryId ?? baseTask.categoryId,
            tags: baseTask.tags,
            parentRecurrenceId: baseTask.parentRecurrenceId,
            recurrenceRule: baseTask.recurrenceRule,
          ),
        );
      }
    }

    final merged = <TaskModel>[];
    // Keep non-series tasks and add updated series tasks once
    for (final t in tasksAfterRemoval) {
      if (t.title != baseTask.title) {
        merged.add(t);
      }
    }
    merged.addAll(additionsOrUpdates);

    // Update notifications as needed
    for (final t in additionsOrUpdates) {
      if (t.reminderTime != null) {
        await _scheduleTaskNotification(t);
      }
    }

    _updateState(merged);
  }

  void addQuickTask(String title, int dayOfWeek) {
    addTask(title, dayOfWeek);
  }

  void toggleTaskCompletion(String taskId) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      final updatedTasks = currentState.weeklyState.tasks.map((task) {
        if (task.id == taskId) {
          return task.copyWith(isCompleted: !task.isCompleted);
        }
        return task;
      }).toList();

      _updateState(updatedTasks);
    }
  }

  void _updateState(List<TaskModel> tasks) {
    final weekNumber = _getCurrentWeekNumber();
    final totalTasks = tasks.length;
    final completedTasks = tasks.where((task) => task.isCompleted).length;
    final completionPercentage = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0.0;
    final dayStats = _calculateDayStats(tasks);

    final newState = WeeklyStateModel(
      tasks: tasks,
      weekNumber: weekNumber,
      totalTasks: totalTasks,
      completedTasks: completedTasks,
      completionPercentage: completionPercentage,
      dayStats: dayStats,
    );

    HiveService.saveTasks(tasks);

    emit(WeeklySuccess(newState));
  }

  List<TaskModel> getAllTasks() {
    if (state is WeeklySuccess) {
      return (state as WeeklySuccess).weeklyState.tasks;
    }
    return [];
  }

  void toggleDayCollapsed(int dayOfWeek) {
    if (state is WeeklySuccess) {
      final current = (state as WeeklySuccess).weeklyState;
      final updated = Set<int>.from(current.collapsedDays);
      if (updated.contains(dayOfWeek)) {
        updated.remove(dayOfWeek);
      } else {
        updated.add(dayOfWeek);
      }
      emit(WeeklySuccess(current.copyWith(collapsedDays: updated)));
    }
  }

  bool areAllTasksCompletedForDay(int dayOfWeek) {
    if (state is WeeklySuccess) {
      final current = (state as WeeklySuccess).weeklyState;
      final dayTasks = current.tasks.where((t) => t.dayOfWeek == dayOfWeek).toList();
      if (dayTasks.isEmpty) return false;
      return dayTasks.every((t) => t.isCompleted);
    }
    return false;
  }

  static int _getCurrentWeekNumber() {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);

    final startOfYear = DateTime(today.year, 1, 1);

    final startOfYearWeekday = startOfYear.weekday == 7 ? 0 : startOfYear.weekday;

    final daysToSubtract = startOfYearWeekday == 0 ? 0 : 7 - startOfYearWeekday;

    final firstWeekStart = startOfYear.subtract(Duration(days: daysToSubtract));

    final todayWeekday = today.weekday == 7 ? 0 : today.weekday;
    final startOfCurrentWeek = today.subtract(Duration(days: todayWeekday));

    final daysSinceStart = startOfCurrentWeek.difference(firstWeekStart).inDays;

    return (daysSinceStart ~/ 7) + 1;
  }

  void testWeekCalculation() {
    final testDates = [
      DateTime(2025, 1, 1), // 1 يناير 2025 (الأربعاء)
      DateTime(2025, 1, 4), // 4 يناير 2025 (السبت)
      DateTime(2025, 8, 16), // 16 أغسطس 2025 (السبت)
    ];

    for (final date in testDates) {
      final weekNum = _getWeekNumberForDate(date);
      print('التاريخ: ${date.day}/${date.month}/${date.year} = الأسبوع $weekNum');
    }
  }

  static int _getWeekNumberForDate(DateTime targetDate) {
    final today = DateTime(targetDate.year, targetDate.month, targetDate.day);

    final startOfYear = DateTime(today.year, 1, 1);
    final startOfYearWeekday = startOfYear.weekday == 7 ? 0 : startOfYear.weekday;
    final daysToSubtract = startOfYearWeekday == 0 ? 0 : 7 - startOfYearWeekday;
    final firstWeekStart = startOfYear.subtract(Duration(days: daysToSubtract));

    final todayWeekday = today.weekday == 7 ? 0 : today.weekday;
    final startOfCurrentWeek = today.subtract(Duration(days: todayWeekday));

    final daysSinceStart = startOfCurrentWeek.difference(firstWeekStart).inDays;
    return (daysSinceStart ~/ 7) + 1;
  }

  List<DayStats> _calculateDayStats(List<TaskModel> tasks) {
    final weekStart = _currentWeekStart; // Use the current week start
    final dayNames = _getDayNames(weekStart);
    final dayStats = <DayStats>[];

    for (int i = 0; i < 7; i++) {
      final dayTasks = tasks.where((task) => task.dayOfWeek == i).toList();
      final totalTasks = dayTasks.length;
      final completedTasks = dayTasks.where((task) => task.isCompleted).length;
      final date = _getDateForDayIndex(i, weekStart);

      dayStats.add(
        DayStats(
          dayOfWeek: i,
          dayName: dayNames[i],
          totalTasks: totalTasks,
          completedTasks: completedTasks,
          date: date,
        ),
      );
    }

    return dayStats;
  }

  List<String> _getDayNames(WeekStart weekStart) {
    final dayNames = <String>[];

    switch (weekStart) {
      case WeekStart.saturday:
        dayNames.addAll([
          'saturday',
          'sunday',
          'monday',
          'tuesday',
          'wednesday',
          'thursday',
          'friday',
        ]);
        break;
      case WeekStart.sunday:
        dayNames.addAll([
          'sunday',
          'monday',
          'tuesday',
          'wednesday',
          'thursday',
          'friday',
          'saturday',
        ]);
        break;
      case WeekStart.monday:
        dayNames.addAll([
          'monday',
          'tuesday',
          'wednesday',
          'thursday',
          'friday',
          'saturday',
          'sunday',
        ]);
        break;
      case WeekStart.tuesday:
        dayNames.addAll([
          'tuesday',
          'wednesday',
          'thursday',
          'friday',
          'saturday',
          'sunday',
          'monday',
        ]);
        break;
      case WeekStart.wednesday:
        dayNames.addAll([
          'wednesday',
          'thursday',
          'friday',
          'saturday',
          'sunday',
          'monday',
          'tuesday',
        ]);
        break;
      case WeekStart.thursday:
        dayNames.addAll([
          'thursday',
          'friday',
          'saturday',
          'sunday',
          'monday',
          'tuesday',
          'wednesday',
        ]);
        break;
      case WeekStart.friday:
        dayNames.addAll([
          'friday',
          'saturday',
          'sunday',
          'monday',
          'tuesday',
          'wednesday',
          'thursday',
        ]);
        break;
    }

    return dayNames;
  }

  String _getDateForDayIndex(int dayIndex, WeekStart weekStart) {
    final now = DateTime.now();
    final startOfWeek = _getStartOfWeek(now, weekStart);
    final targetDate = startOfWeek.add(Duration(days: dayIndex));

    final day = targetDate.day.toString().padLeft(2, '0');
    final month = targetDate.month.toString().padLeft(2, '0');

    return '$day/$month';
  }

  DateTime _getStartOfWeek(DateTime date, WeekStart weekStart) {
    final weekday = date.weekday; // Monday = 1, Sunday = 7

    int weekStartDay;
    switch (weekStart) {
      case WeekStart.monday:
        weekStartDay = 1;
        break;
      case WeekStart.tuesday:
        weekStartDay = 2;
        break;
      case WeekStart.wednesday:
        weekStartDay = 3;
        break;
      case WeekStart.thursday:
        weekStartDay = 4;
        break;
      case WeekStart.friday:
        weekStartDay = 5;
        break;
      case WeekStart.saturday:
        weekStartDay = 6;
        break;
      case WeekStart.sunday:
        weekStartDay = 7;
        break;
    }

    int daysToSubtract = weekday - weekStartDay;
    if (daysToSubtract < 0) {
      daysToSubtract += 7;
    }

    return date.subtract(Duration(days: daysToSubtract));
  }

  List<TaskModel> getTasksForDay(int dayOfWeek) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      return currentState.weeklyState.tasks.where((task) => task.dayOfWeek == dayOfWeek).toList();
    }
    return [];
  }

  List<TaskModel> getImportantTasksForDay(int dayOfWeek) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      return currentState.weeklyState.tasks
          .where((task) => task.dayOfWeek == dayOfWeek && task.isImportant)
          .toList();
    }
    return [];
  }

  List<TaskModel> getOtherTasksForDay(int dayOfWeek) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      return currentState.weeklyState.tasks
          .where((task) => task.dayOfWeek == dayOfWeek && !task.isImportant)
          .toList();
    }
    return [];
  }

  Future<void> reloadTasksFromStorage() async {
    List<TaskModel> tasks = HiveService.loadTasks();
    tasks = tasks.where((task) => !_isAutoGeneratedTask(task)).toList();
    _updateState(tasks);
  }

  int getOverdueTasksCount() {
    if (state is WeeklySuccess) {
      final tasks = (state as WeeklySuccess).weeklyState.tasks;
      return tasks.where((t) => t.isOverdue).length;
    }
    return 0;
  }

  int getCurrentStreak() {
    if (state is! WeeklySuccess) return 0;
    final tasks = (state as WeeklySuccess).weeklyState.tasks;
    if (tasks.isEmpty) return 0;

    final today = DateTime.now();
    int streak = 0;

    for (int i = 0; i < 30; i++) {
      final checkDate = today.subtract(Duration(days: i));
      final appDayIndex = _mapDateTimeToAppDayIndex(checkDate);
      if (appDayIndex == null) {
        streak++;
        continue;
      }
      final dayTasks = tasks.where((t) => t.dayOfWeek == appDayIndex).toList();
      if (dayTasks.isEmpty) {
        streak++;
      } else if (dayTasks.every((t) => t.isCompleted)) {
        streak++;
      } else {
        break;
      }
    }

    return streak;
  }

  int? _mapDateTimeToAppDayIndex(DateTime date) {
    switch (date.weekday) {
      case DateTime.saturday:
        return 0;
      case DateTime.sunday:
        return 1;
      case DateTime.monday:
        return 2;
      case DateTime.tuesday:
        return 3;
      case DateTime.wednesday:
        return 4;
      case DateTime.thursday:
        return 5;
      case DateTime.friday:
        return null; // Day off in app model
      default:
        return null;
    }
  }

  bool _isAutoGeneratedTask(TaskModel task) {
    final autoGeneratedTitles = [];
    return autoGeneratedTitles.contains(task.title);
  }

  void editTask(
    String taskId,
    String newTitle, {
    bool? isImportant,
    TimeOfDay? reminderTime,
    String? categoryId,
    TaskPriority? priority,
  }) async {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      TaskModel? originalTask;
      TaskModel? updatedTask;

      final updatedTasks = currentState.weeklyState.tasks.map((task) {
        if (task.id == taskId) {
          originalTask = task;
          updatedTask = task.copyWith(
            title: newTitle,
            isImportant: isImportant ?? task.isImportant,
            reminderTime: reminderTime ?? task.reminderTime,
            categoryId: categoryId ?? task.categoryId,
            priority: priority ?? task.priority,
          );
          return updatedTask!;
        }
        return task;
      }).toList();

      // تحديث الإشعارات لو حصل تغيير في التذكير
      if (originalTask != null && updatedTask != null) {
        await _updateTaskNotification(originalTask!, updatedTask!);
      }

      _updateState(updatedTasks);
    }
  }

  void deleteTask(String taskId) async {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;

      // Cancel notification for the deleted task
      await _cancelTaskNotification(taskId);

      final updatedTasks = currentState.weeklyState.tasks
          .where((task) => task.id != taskId)
          .toList();

      _updateState(updatedTasks);
    }
  }

  void clearTasksForDay(int dayOfWeek) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;

      final tasksToClear = currentState.weeklyState.tasks.where(
        (task) => task.dayOfWeek == dayOfWeek,
      );

      // Cancel notifications for all tasks being cleared
      for (final task in tasksToClear) {
        _cancelTaskNotification(task.id);
      }

      final updatedTasks = currentState.weeklyState.tasks
          .where((task) => task.dayOfWeek != dayOfWeek)
          .toList();

      _updateState(updatedTasks);
    }
  }

  void clearAllTasks() {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;

      // Cancel all notifications for existing tasks
      for (final task in currentState.weeklyState.tasks) {
        _cancelTaskNotification(task.id);
      }

      _updateState([]);
    }
  }

  /// Generate recurring task instances for the next few weeks/months
  List<TaskModel> _generateRecurringInstances(TaskModel parentTask, RecurrenceRule recurrenceRule) {
    final instances = <TaskModel>[];
    final now = DateTime.now();
    final endDate = now.add(const Duration(days: 90)); // Generate for next 3 months

    final occurrences = recurrenceRule.generateOccurrences(now, endDate);

    for (final occurrence in occurrences) {
      // Skip the original task date
      if (occurrence.isAtSameMomentAs(now)) continue;

      final dayIndex = _mapDateTimeToAppDayIndex(occurrence);
      if (dayIndex == null) continue; // Skip Friday (day off)

      final instance = parentTask.copyWith(
        id: _uuid.v4(),
        parentRecurrenceId: parentTask.id,
        dayOfWeek: dayIndex,
        createdAt: occurrence,
        isCompleted: false,
        completedAt: null,
      );

      instances.add(instance);
    }

    return instances;
  }

  /// Delete a recurring task series or single instance
  void deleteRecurringTask(String taskId, {bool deleteEntireSeries = false}) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      final task = currentState.weeklyState.tasks.firstWhere((t) => t.id == taskId);

      List<TaskModel> updatedTasks;

      if (deleteEntireSeries || task.isRecurrenceParent) {
        // Delete the entire series
        final seriesId = task.isRecurrenceParent ? task.id : task.parentRecurrenceId;
        final tasksToDelete = currentState.weeklyState.tasks
            .where((t) => t.id != seriesId && t.parentRecurrenceId != seriesId)
            .toList();

        // Cancel notifications for parent and all instances in the series
        for (final t in currentState.weeklyState.tasks) {
          if (t.id == seriesId || t.parentRecurrenceId == seriesId) {
            _cancelTaskNotification(t.id);
          }
        }

        updatedTasks = tasksToDelete;
      } else {
        // Delete only this instance
        // Cancel notification for this instance
        _cancelTaskNotification(taskId);

        updatedTasks = currentState.weeklyState.tasks.where((t) => t.id != taskId).toList();
      }

      _updateState(updatedTasks);
    }
  }

  /// Edit a recurring task series or single instance
  void editRecurringTask(
    String taskId,
    String newTitle, {
    bool? isImportant,
    TimeOfDay? reminderTime,
    TaskPriority? priority,
    String? categoryId,
    bool editEntireSeries = false,
  }) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      final task = currentState.weeklyState.tasks.firstWhere((t) => t.id == taskId);

      List<TaskModel> updatedTasks;

      if (editEntireSeries || task.isRecurrenceParent) {
        // Edit the entire series
        final seriesId = task.isRecurrenceParent ? task.id : task.parentRecurrenceId;
        updatedTasks = currentState.weeklyState.tasks.map((t) {
          if (t.id == seriesId || t.parentRecurrenceId == seriesId) {
            return t.copyWith(
              title: newTitle,
              isImportant: isImportant ?? t.isImportant,
              reminderTime: reminderTime,
              priority: priority ?? t.priority,
              categoryId: categoryId ?? t.categoryId,
            );
          }
          return t;
        }).toList();

        // Update notifications for all affected tasks in the series
        for (final t in updatedTasks) {
          if (t.id == seriesId || t.parentRecurrenceId == seriesId) {
            // Find original version of this task before update
            final original = currentState.weeklyState.tasks.firstWhere(
              (o) => o.id == t.id,
              orElse: () => t,
            );
            _updateTaskNotification(original, t);
          }
        }
      } else {
        // Edit only this instance - break it from the series
        updatedTasks = currentState.weeklyState.tasks.map((t) {
          if (t.id == taskId) {
            return t.copyWith(
              title: newTitle,
              isImportant: isImportant ?? t.isImportant,
              reminderTime: reminderTime,
              priority: priority ?? t.priority,
              categoryId: categoryId ?? t.categoryId,
              parentRecurrenceId: null, // Break from series
              recurrenceRule: null,
            );
          }
          return t;
        }).toList();

        // Update notification for the single edited instance
        final originalTask = currentState.weeklyState.tasks.firstWhere((o) => o.id == taskId);
        final updatedTask = updatedTasks.firstWhere((u) => u.id == taskId);
        _updateTaskNotification(originalTask, updatedTask);
      }

      _updateState(updatedTasks);
    }
  }

  /// Get all tasks in a recurring series
  List<TaskModel> getRecurringSeries(String taskId) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      final task = currentState.weeklyState.tasks.firstWhere((t) => t.id == taskId);

      if (task.isRecurrenceParent) {
        return currentState.weeklyState.tasks
            .where((t) => t.id == taskId || t.parentRecurrenceId == taskId)
            .toList();
      } else if (task.isRecurrenceInstance) {
        return currentState.weeklyState.tasks
            .where(
              (t) =>
                  t.parentRecurrenceId == task.parentRecurrenceId ||
                  t.id == task.parentRecurrenceId,
            )
            .toList();
      }
    }
    return [];
  }

  /// Schedule a notification for a task
  Future<void> _scheduleTaskNotification(TaskModel task) async {
    if (task.reminderTime == null) return;

    try {
      final notificationService = NotificationService();
      final scheduledDateTime = _getTaskNotificationDateTime(task);

      if (scheduledDateTime == null || scheduledDateTime.isBefore(DateTime.now())) {
        return; // Don't schedule notifications in the past
      }

      final notificationId = task.id.hashCode; // Use task ID hash as notification ID
      final title = 'Task Reminder';
      final body = task.title;
      final payload = task.id;

      await notificationService.scheduleNotification(
        id: notificationId,
        title: title,
        body: body,
        scheduledTime: scheduledDateTime,
        payload: payload,
      );
    } catch (e) {
      // Log error but don't throw - notification scheduling shouldn't break task creation
      print('Failed to schedule notification for task ${task.id}: $e');
    }
  }

  /// Update notification when task is edited
  Future<void> _updateTaskNotification(TaskModel originalTask, TaskModel updatedTask) async {
    try {
      final notificationService = NotificationService();
      final notificationId = originalTask.id.hashCode;

      // If reminder time was removed, cancel the notification
      if (updatedTask.reminderTime == null) {
        await notificationService.cancelNotification(notificationId);
        return;
      }

      // If reminder time was added or changed, update the notification
      final newScheduledDateTime = _getTaskNotificationDateTime(updatedTask);
      if (newScheduledDateTime == null || newScheduledDateTime.isBefore(DateTime.now())) {
        await notificationService.cancelNotification(notificationId);
        return;
      }

      final title = 'Task Reminder';
      final body = updatedTask.title;
      final payload = updatedTask.id;

      await notificationService.updateNotification(
        id: notificationId,
        title: title,
        body: body,
        newTime: newScheduledDateTime,
        payload: payload,
      );
    } catch (e) {
      print('Failed to update notification for task ${updatedTask.id}: $e');
    }
  }

  /// Cancel notification when task is deleted
  Future<void> _cancelTaskNotification(String taskId) async {
    try {
      final notificationService = NotificationService();
      final notificationId = taskId.hashCode;
      await notificationService.cancelNotification(notificationId);
    } catch (e) {
      print('Failed to cancel notification for task $taskId: $e');
    }
  }

  /// Get the DateTime when the notification should be scheduled
  DateTime? _getTaskNotificationDateTime(TaskModel task) {
    if (task.reminderTime == null) return null;

    final now = DateTime.now();
    final reminderTime = task.reminderTime!;

    // Calculate the target date based on the task's day of week
    final targetDate = _getDateForTaskDay(task.dayOfWeek);

    // Combine date and time
    final scheduledDateTime = DateTime(
      targetDate.year,
      targetDate.month,
      targetDate.day,
      reminderTime.hour,
      reminderTime.minute,
    );

    // If the scheduled time is in the past, schedule for next week
    if (scheduledDateTime.isBefore(now)) {
      return scheduledDateTime.add(const Duration(days: 7));
    }

    return scheduledDateTime;
  }

  /// Get the actual date for a task's day of week
  DateTime _getDateForTaskDay(int dayOfWeek) {
    final now = DateTime.now();
    final startOfWeek = _getStartOfWeek(now, _currentWeekStart);
    return startOfWeek.add(Duration(days: dayOfWeek));
  }

  @override
  Future<void> close() async {
    await HiveService.close();
    super.close();
  }
}
